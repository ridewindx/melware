package session

import (
	"net/http"
	"log"
	"sync"
	"github.com/ridewindx/mel"
)

// Default flashes key.
const flashesKey = "_flash"

// Options stores configuration for a session or session store.
// Fields are a subset of http.Cookie fields.
type Options struct {
	Path   string
	Domain string
	// MaxAge=0 means no 'Max-Age' attribute specified.
	// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'.
	// MaxAge>0 means Max-Age attribute present and given in seconds.
	MaxAge   int
	Secure   bool
	HttpOnly bool
}

// Session stores the values and optional configuration for a session.
type RawSession struct {
	// The ID of the session, generated by stores. It should not be used for
	// user data.
	ID string
	// Values contains the user-data for the session.
	Values  map[interface{}]interface{}
	Options *Options
	IsNew   bool
	store   Store
	name    string
}

// NewSession is called by session stores to create a new session instance.
func NewSession(store Store, name string) *RawSession {
	return &RawSession{
		Values: make(map[interface{}]interface{}),
		store:  store,
		name:   name,
	}
}

// Flashes returns a slice of flash messages from the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *RawSession) Flashes(vars ...string) []interface{} {
	var flashes []interface{}
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	if v, ok := s.Values[key]; ok {
		// Drop the flashes and return it.
		delete(s.Values, key)
		flashes = v.([]interface{})
	}
	return flashes
}

// AddFlash adds a flash message to the session.
//
// A single variadic argument is accepted, and it is optional: it defines
// the flash key. If not defined "_flash" is used by default.
func (s *RawSession) AddFlash(value interface{}, vars ...string) {
	key := flashesKey
	if len(vars) > 0 {
		key = vars[0]
	}
	var flashes []interface{}
	if v, ok := s.Values[key]; ok {
		flashes = v.([]interface{})
	}
	s.Values[key] = append(flashes, value)
}

// Save is a convenience method to save this session. It is the same as calling
// store.Save(request, response, session). You should call Save before writing to
// the response or returning from the handler.
func (s *RawSession) Save(r *http.Request, w http.ResponseWriter) error {
	return s.store.Save(r, w, s)
}

// Name returns the name used to register the session.
func (s *RawSession) Name() string {
	return s.name
}

// Store returns the session store used to register the session.
func (s *RawSession) Store() Store {
	return s.store
}


// Wraps thinly gorilla-session methods.
// Session stores the values and optional configuration for a session.
type Session interface {
	// Get returns the session value associated to the given key.
	Get(key interface{}) interface{}
	// Set sets the session value associated to the given key.
	Set(key interface{}, val interface{})
	// Delete removes the session value associated to the given key.
	Delete(key interface{})
	// Clear deletes all values in the session.
	Clear()
	// AddFlash adds a flash message to the session.
	// A single variadic argument is accepted, and it is optional: it defines the flash key.
	// If not defined "_flash" is used by default.
	AddFlash(value interface{}, vars ...string)
	// Flashes returns a slice of flash messages from the session.
	// A single variadic argument is accepted, and it is optional: it defines the flash key.
	// If not defined "_flash" is used by default.
	Flashes(vars ...string) []interface{}
	// Options sets confuguration for a session.
	Options(Options)
	// Save saves all sessions used during the current request.
	Save() error
}

const (
	DefaultKey  = "github.com/gin-contrib/sessions"
)

func Sessions(name string, store Store) mel.Handler {
	return func(c *mel.Context) {
		s := &session{name, c.Request, store, nil, false, c.Writer}
		c.Set(DefaultKey, s)
		defer func() {
			mutex.Lock()
			delete(sessionRegistry, c.Request)
			mutex.Unlock()
		}()
		c.Next()
	}
}

type session struct {
	name    string
	request *http.Request
	store   Store
	session *RawSession
	written bool
	writer  http.ResponseWriter
}

func (s *session) Get(key interface{}) interface{} {
	return s.Session().Values[key]
}

func (s *session) Set(key interface{}, val interface{}) {
	s.Session().Values[key] = val
	s.written = true
}

func (s *session) Delete(key interface{}) {
	delete(s.Session().Values, key)
	s.written = true
}

func (s *session) Clear() {
	s.Session().Values = make(map[interface{}]interface{})
	s.written = true
}

func (s *session) AddFlash(value interface{}, vars ...string) {
	s.Session().AddFlash(value, vars...)
	s.written = true
}

func (s *session) Flashes(vars ...string) []interface{} {
	s.written = true
	return s.Session().Flashes(vars...)
}

func (s *session) Options(options Options) {
	s.Session().Options = &Options{
		Path:     options.Path,
		Domain:   options.Domain,
		MaxAge:   options.MaxAge,
		Secure:   options.Secure,
		HttpOnly: options.HttpOnly,
	}
}

func (s *session) Save() error {
	if !s.Written() {
		return nil
	}
	err := s.Session().Save(s.request, s.writer)
	if err == nil {
		s.written = false
	}
	return err
}

func (s *session) Session() *RawSession {
	if s.session == nil {
		var err error
		s.session, err = s.store.Get(s.request, s.name)
		if err != nil {
			log.Printf("[sessions] ERROR! %s\n", err) // TODO
		}
	}
	return s.session
}

func (s *session) Written() bool {
	return s.written
}

// shortcut to get session
func Default(c *mel.Context) Session {
	return c.MustGet(DefaultKey).(Session)
}

var mutex sync.RWMutex
var sessionRegistry = make(map[*http.Request]map[string]sessionInfo)

// sessionInfo stores a session tracked by the registry.
type sessionInfo struct {
	s *RawSession
	e error
}

func getSession(store Store, r *http.Request, name string) (*RawSession, error) {
	var reg map[string]sessionInfo
	mutex.RLock()
	reg, ok := sessionRegistry[r]
	mutex.RUnlock()
	if !ok {
		reg = make(map[string]sessionInfo)
		mutex.Lock()
		sessionRegistry[r] = reg
		mutex.Unlock()
	}

	info, ok := reg[name]
	if ok {
		return info.s, info.e
	}
	session, err := store.New(r, name)
	session.name = name
	session.store = store
	reg[name] = sessionInfo{s: session, e: err}
	return session, err
}
